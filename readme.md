<div dir="rtl">

# پروژه درس شبیه سازی کامپیوتری

### اعضای گروه:

<ul>

<li>
محمدطه جهانی نژاد - ۹۸۱۰۱۳۶۳
</li>

<li>
شهاب حسینی مقدم - ۹۸۱۰۵۷۱۶
</li>

</ul>

## موجودیت ها 

در این بخش به توضیح موجودیت هایی که در کد داریم می پردازیم.

## Job

از این موجودیت برای نشان دادن جاب هایی که قرار است توسط پردازنده اجرا شوند استفاده می کنیم.
این موجودیت اطلاعاتی نظیر زمان ایجاد، زمان ورود و خروج به هر صف، مدت زمان اجرا شده و اولویت جاب را در خود نگه می دارد.
همچنین توابعی دارد که در زیر آنها را شرح می دهیم:

#### <span dir="ltr"> execute(self, time) </span>

این تابع زمانی اجرا می شود که نوبت اجرای پردازه رسیده باشد.
به اندازه ی پارامتر time، به زمان اجرای آن اضافه می کند.

#### <span dir="ltr"> time_remaining(self) </span>

زمان باقی مانده از اجرای پردازه را بر میگرداند.

#### <span dir="ltr"> time_remaining(self) </span>

زمان باقی مانده از اجرا را بر می گرداند.

#### <span dir="ltr"> is_finished(self) </span>

در صورتی که اجرای پردازه تمام شده باشد مقدار True و در غیر این صورت مقدار False را بر می گرداند.

#### <span dir="ltr"> done_percent(self) </span>

درصد زمانی که از انجام کار انجام شده است را بر میگرداند.
(برای بخش گرافیک)

#### <span dir="ltr"> __init__(self, service_time, priority, creation_time) </span>

این تابع هم constructor کلاس است. تنها نکته مهم آن هم این است که در داخل کلاس، تعداد پردازه های ساخته شده تا کنون نگهداری می شود
و با استفاده از آن، یک id به هر پردازه اختصاص داده می شود.

#### <span dir="ltr"> __lt__(self, o) و __eq__(self, o) </span>

پایتون از این دو تابع برای مقایسه کردن دو آبجکت از جنس Job استفاده می کند.
نحوه پیاده سازی این دو تابع به نحوی است که پردازه ای کوچکتر است که اولویت آن بزرگتر باشد.
اگر دو پردازه اولویت برابر داشتند، پردازه ای کوچکتر است که زمان تولید آن قدیمی تر باشد.
(به این دلیل پردازه با اولویت بالاتر را کوچکتر گرفته ایم که بعدا با استفاده از یک heap کمینه، پردازه ها را مرتب کنیم.)

## CPU

این کلاس نماینده ی CPU است.
صف های RR1، RR2، FCFS، و Priority Queue در آن نگه داری می شوند.
همچنین پردازه ی در حال اجرا هم در متغیر to_execute در آن نگه داری می شود.

#### <span dir="ltr"> get_job_by_id(self, job_id: int) </span>

بین تمام صف ها می گردد و پردازه ای با آیدی مشخص شده بر می گرداند.
(برای بخش گرافیکی)

#### <span dir="ltr"> add_job(self, job: Job) </span>

یک پردازه را به priority queue اضافه می کند.

#### <span dir="ltr"> move_job_to_roundrobinT1(self) </span>

یک پردازه را priority queue به RR1 انتفال می دهد و زمان ورود آن به صف را نیز ثبت می کند.

#### <span dir="ltr"> move_to_next_queue(self, job: Job, queue: list) </span>

یک پردازه را از صفی که در حال حاضر در آن قرار دارد به صف بعدی (با اولویت پایینتر) انتفال می دهد.
همچنین، زمان خروج از صف قبلی و ورود به صف جدید را ثبت می کند.
#### <span dir="ltr"> job_finished(self, job) </span>

وقتی که اجرای یک پردازه تمام شده باشد صدا زده می شود و آن پردازه را از صفی که در آن است حذف می کند.

#### <span dir="ltr"> dispatcher(self) </span>

این تابع ابتدا صف ها را به ترتیب اولویت آنها بررسی می کند تا ببیند که کدام صف یک پردازه ی آماده ی اجرا دارد.
سپس آن را به اندازه ای که سیاست صف اجازه می دهد
(
پنج واحد برای RR1
،
پنج واحد برای RR2
،
و مدت نامحدود برای FCFS
)
اجرا می کند.
سپس اگر که زمان اجرای پردازه از زمان مجاز برای آن صف بیشتر شد،
پردازه به صف بعدی منتقل می شود.
اگر هم که اجرا تمام شد، آن را از صف خارج می کند.

#### <span dir="ltr"> count_jobs_in_queues(self) </span>

تعداد تمام پردازه هایی که در حال اجرا هستند را بر می گرداند.
(که اگر کم بودند تعدادی پردازه از priority queue وارد کند.)

#### <span dir="ltr">  </span>

## Main

این کلاس CPU را می سازد و توابع آن را صدا می زند.

#### <span dir="ltr"> jobCreator(self) </span>

این تابع با صدا زدن توابع
<span dir="ltr">`numpy.random.exponential()`</span>
و
<span dir="ltr">`numpy.random.poisson()`</span>
زمان interarrival و زمان سرویس پردازه جدید را تعیین کرده و با توجه به احتمالاتی که در داک پروژه آمده،
priority
آن را نیز تعیین می کند.
سپس پردازه را ایجاد کرده و به همراه interarrival پردازه بعدی بر می گرداند.


#### <span dir="ltr"> jobLoader(self) </span>

هر گاه که کمتر از k پردازه در CPU بود، به CPU اطلاع می دهد که k پردازه جدید وارد RR1 کند.

#### <span dir="ltr"> check_job_creation(self) </span>

اگر زمان ایجاد پردازه بعدی رسیده باشد، پردازه جدید را گرفته و به لیست پردازه های CPU اضافه می کند.
همچنین زمان ایجاد پردازه بعدی را به روز رسانی می کند.

#### <span dir="ltr"> render_display(self) </span>

این تابع برای بخش گرافیک استفاده می شود که توضیح آن در گزارش پروژه نمی گنجد.

#### <span dir="ltr"> run_main_thread(self) </span>

این تابع هر یک ثانیه هر یک از توابع بالا را صدا می زند.
همچنین تابعی از Reporter را صدا می زند که طول هر صف را طی زمان ثبت کند.
در واقع نقش کلاک را ایفا می کند.

#### <span dir="ltr"> start_program(self) </span>

این تابع ورودی ها را دریافت می کند و بخش گرافیک و CPU را راه اندازی می کند.

## Reporter

این کلاس برای ثبت دیتای مربوط به شبیه سازی استفاده می شود.

#### <span dir="ltr"> ecdf(self, a) و plot_ecdf(self, a, pos, cap)</span>

این دو تابع برای رسم تابع توزیع تجمعی زمان انتظار استفاده می شوند و از
[این لینک](https://stackoverflow.com/a/65972406)
گرفته شده اند.

#### <span dir="ltr"> capture_len(self, cpu) </span>

این تابع در هر واحد زمانی صدا زده می شود و طول هر یک از صف ها را ثبت می کند.

#### <span dir="ltr"> calculate_len_avg(self) </span>

این تابع میانگین طول هر یک از صف ها را حساب می کند.

#### <span dir="ltr"> draw_wait_plot(self, rr1_list, rr2_list, fcfs_list) </span>

با کمک توابعی که قبلا معرفی شد، تابع توزیع تجمعی میزان انتظار را رسم می کند.
البته اگر توابع به صفی وارد نشده باشند از آن صرف نظر می کند.

#### <span dir="ltr"> calculate_job_timers(job, time: int) </span>

گفته شد که هر پردازه زمان ورود و خروجش به هر صف را ثبت می کند.
این تابع با استفاده از این داده ها، برای هر پردازه زمانی را که در هر صف سپری کرده محاسبه و خروجی می دهد.

#### <span dir="ltr"> calculate_spent_time_queues(self, jobs, time:int) </span>

این تابع با کمک خروجی تابع قبلی،
میانگین زمان سپری شده ی پردازه ها در هر صف را محاسبه می کند.
همچنین نمودار توزیع تجمعی را رسم می کند.

#### <span dir="ltr"> export(self, total_clocks, cpu, jobs) </span>

این همان تابعی است که در انتهای کار توسط Main صدا زده می شود.
این تابع برخی خروجی ها را پرینت می کند و توابع دیگر را صدا می زند.

## اجرا 

<div dir="ltr">

```commandline
pip install pygame
pip install numpy
```

</div>

اگر که از پراکسی استفاده می کنید، دستور را به صورت زیر اجرا کنید.

<div dir="ltr">

```commandline
pip install --proxy http://ip:port pygame
pip install --proxy http://ip.port numpy
```

</div>

سپس در دایرکتوری اصلی پروژه، دستور زیر را اجرا کنید.

<div dir="ltr">

```commandline
python main.py
```

</div>

## خروجی 

صفحه ی گرافیکی به صورت زیر است:

![graphics output](/readme-assets/pygame.png)

رنگ سبز نشان دهنده اولویت پایین،
زرد اولویت متوسط،
و قرمز اولویت بالا است.

همچنین درصد اتمام هر پردازه هم با پایین آمدن نوار سفید رنگ داخل آن مشخص می شود.
به طوری که وقتی داخل مربع کاملا رنگی شود یعنی کار تمام شده و از صف خارج می شود.

همچنین با کلیک روی یک پردازه می توان اطلاعات مربوط به آن را مشاهده کرد.

پس از اتمام شبیه سازی، نمودار توزیع تجمعی مدت انتظار در هر صف نمایش داده می شود که به صورت زیر است:

![cdf of waiting times per list](/readme-assets/wait_cdf.png)

داده های خروجی داده شده هم به صورت زیر هستند.

<div dir="ltr">

```commandline
average length of each queue is as follows:
RR1: 1.61
RR2: 3.36
fcfs: 0.02
cpu utilization was 1.00
average time spent in RR1 is 19.0
average time spent in RR2 is 46.78
average time spent in FCFS is 3.0
```

</div>


</div>